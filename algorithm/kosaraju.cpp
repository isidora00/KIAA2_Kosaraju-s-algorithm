#include "kosaraju.hpp"
#include <fstream>

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w);
}

Graph Graph::getTransposeGraph()
{
    Graph Grev(V);
    for (int v = 0; v < V; v++)
    {
        vector<int>::iterator i;
        for (i = adj[v].begin(); i != adj[v].end(); i++)
        {
            Grev.addEdge(*i, v);
        }
    }
    return Grev;
}

void Graph::DFSReversedGraph(Graph &G, int v, vector<bool> &visited, stack<int> &visitOrder)
{
    visited[v] = true;
    vector<int>::iterator i;
    for (i = G.adj[v].begin(); i != G.adj[v].end(); i++)
        if (!visited[*i])
            DFSReversedGraph(G, *i, visited, visitOrder);

    // finished visiting vertex v
    visitOrder.push(v);
}

void Graph::DFS(int v, vector<bool> &visited, vector<int> &currentComponent)
{
    visited[v] = true;
    vector<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); i++)
        if (!visited[*i])
        {
            currentComponent.push_back(*i);
            DFS(*i, visited, currentComponent);
        }
}

vector<vector<int>> Graph::findComponents()
{
    // calculate transponse graph
    Graph Grev = this->getTransposeGraph();

    // DFS on transponse graph, keep track of order of visited vertex
    vector<bool> visited(V, false);
    stack<int> visitOrder;
    for (int i = 0; i < V; i++)
        if (!visited[i])
            DFSReversedGraph(Grev, i, visited, visitOrder);

    // DFS on regular graph, keep track of calculated strongly connected components
    std::fill(visited.begin(), visited.end(), false);
    vector<vector<int>> result;
    while (!visitOrder.empty())
    {
        int top = visitOrder.top();
        visitOrder.pop();
        if (!visited[top])
        {
            vector<int> currentComponent = {top};
            DFS(top, visited, currentComponent);
            result.push_back(currentComponent);
        }
    }
    return result;
}

void Graph::random_edge(int n, int &i, int &j)
{
    long long k = rand() % (n * n);
    i = k / n;
    j = k % n;
}

Graph *Graph::generateRandomGraph(int n, int m)
{
    int maxEdges = (long long)n * n;
    vector<pair<int, int>> edges;
    if (m < maxEdges / 2)
    {
        // sparse graphs are generated by including random edges
        set<pair<int, int>> include_edges;
        while (include_edges.size() < m)
        {
            int i, j;
            Graph::random_edge(n, i, j);
            include_edges.emplace(i, j);
        }
        std::copy(include_edges.begin(), include_edges.end(), std::back_inserter(edges));
    }
    else
    {
        // dense graphs are generated by excluding random edges (from a full graph)
        set<pair<int, int>> exclude_edges;
        while (exclude_edges.size() + m < maxEdges)
        {
            int i, j;
            Graph::random_edge(n, i, j);
            exclude_edges.emplace(i, j);
        }

        for (int j = 0; j < n; j++)
            for (int i = 0; i < n; i++)
            {
                if (exclude_edges.find(make_pair(i, j)) == exclude_edges.end())
                    edges.emplace_back(i, j);
            }
    }
    // make graph from calculated edges
    Graph *g = new Graph(n);
    for (int i = 0; i < edges.size(); i++)
        g->addEdge(edges[i].first, edges[i].second);
    return g;
}

void Graph::calcuateExecutionTime(string output, int leftBound, int rightBound)
{

    std::ofstream outFile(output);
    int numberOfEdge = 0;
    for (int numberOfVertex = leftBound; numberOfVertex <= rightBound; numberOfVertex++)
    {
        if (numberOfVertex == 1)
            numberOfEdge = rand() % 2;
        else
            numberOfEdge = max(rand() % (numberOfVertex * (numberOfVertex - 1) / 2), numberOfEdge);
        Graph *g = Graph::generateRandomGraph(numberOfVertex, numberOfEdge);

        clock_t start, end;
        start = clock();

        ios_base::sync_with_stdio(false);

        vector<vector<int>> components = g->findComponents();

        end = clock();

        // calculating total time taken by the program.
        double time_taken = double(end - start);
        if (outFile.is_open())
        {
            outFile << numberOfVertex + numberOfEdge << " " << time_taken << "\n";
            delete g;
        }
        else
        {
            std::cerr << "Error opening the file." << std::endl;
            delete g;
            exit(EXIT_FAILURE);
        }
    }
    if (outFile.is_open())
        outFile.close();
}

int main()
{
    //remove comment for measuring execution times for different size inputs
    //Graph::calcuateExecutionTime("../measured_times/data.txt", 1, 1000);

    Graph *g = new Graph(5);

    g->addEdge(0, 2);
    g->addEdge(0, 3);
    g->addEdge(1, 0);
    g->addEdge(2, 1);
    g->addEdge(3, 4);

    vector<vector<int>> ans = g->findComponents();
    cout << "Strongly Connected Components are:\n";
    for (auto x : ans)
    {
        for (auto y : x)
        {
            cout << y << " ";
        }
        cout << "\n";
    }
    delete g;
}
